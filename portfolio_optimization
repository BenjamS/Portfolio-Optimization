library(ggplot2)
library(gridExtra)
library(stats)
library(pracma)
library(nleqslv)
source('D:/OneDrive - CGIAR/Documents/maxEU_constrVC.R')
source('D:/OneDrive - CGIAR/Documents/coloredNoise.R')
# source('~/maxEU_constrVC.R')
# source('~/coloredNoise.R')
#============================================
#N risky assets
#============================================
m_h <- c(0.86, 0.93, 0.99, 1.08, 1.15)
cv_h <- c(0.15, 0.35, 0.52, 0.75, 0.95)
s_h <- cv_h * m_h
m_lk <- log(c(1.3, 1.5, 1.8, 1.2, 1.3))
cv_lk <- c(0.1, 0.12, 0.07, 0.2, 0.3) * sign(m_lk)
s_lk <- cv_lk * m_lk
#--------------------------------------------
n_proj <- length(m_h)
onevec <- rep(1, n_proj)
#--------------------------------------------
# s2_lA <- s_lA^2
# E_lA <- sum(m_lA)
#--------------------------------------------
#Covariance matrices
#--------------------------------------------
#Endogenous params
noisevec <- coloredNoise(n_proj^2, a = -2, normalize = T, graph = T)
Q <- matrix(exp(noisevec), n_proj, n_proj)
Corr <- Q %*% t(Q)
Corr <- Corr / max(Corr) * 0.5
diag(Corr) <- onevec
#print(Corr)
S_h <- diag(s_h) %*% Corr %*% diag(s_h)
Sh_inv <- round(solve(S_h), 5)
#--------------------------------------------
#Exogenous params
noisevec <- coloredNoise(n_proj^2, a = -2, normalize = T, graph = T)
Q <- matrix(exp(noisevec), n_proj, n_proj)
Corr <- Q %*% t(Q)
Corr <- Corr / max(Corr) * 0.5
diag(Corr) <- onevec
#print(Corr)
S_lk <- diag(s_lk) %*% Corr %*% diag(s_lk)
Vexo <- t(onevec) %*% S_lk %*% onevec
#============================================
Vend_targ <- 9
C_targ <- 1
#--------------------------------------------
rootfn <- T
quietly <- F
in_vec <- rnorm(n_proj + 2)
out <- nleqslv(in_vec, maxEU_constrVC, jac = NULL, Vend_targ, C_targ, m_h, S_h, rootfn, quietly)
rootfn <- F
in_star <- out$x
outstar <- maxEU_constrVC(in_star, Vend_targ, C_targ, m_h, S_h, rootfn, quietly)
lwstar <- in_star[1:n_proj]
Cost <- sum(exp(lwstar))
Cost
#============================================
pwr10 <- 2
range_V <- c(6, 13)
first_i <- range_V[1] * 10^pwr10
last_i <- range_V[2] * 10^pwr10
#---------------
EUr_vec <- c()
Vend_vec <- c()
MD_vec <- c()
SOC_vec <- c()
lV_vec <- c()
lC_vec <- c()
Uc_vec <- c()
wstar_list <- list()
slackvec_list <- list()
negpos <- c()
t <- 0
for(i in first_i:last_i){
  #----
  Vend_targ <- i / 10^pwr10
  #----
  for(j in 1:20){
    rootfn <- T
    quietly <- T
    in_vec <- runif(n_proj + 2)
    out <- try(nleqslv(in_vec, maxEU_constrVC, jac = NULL, Vend_targ, C_targ, m_h, S_h, rootfn, quietly))
    if(inherits(out, "try-error")){print("gotta skip"); next()}
    if(max(abs(out$fvec)) > 10^-5){print("max iter with no convergence");next()}
    #----
    instar <- out$x
    #----
    rootfn <- F
    quietly <- T
    outstar <- maxEU_constrVC(instar, Vend_targ, C_targ, m_h, S_h, rootfn, quietly)
    #----
    EUr_try <- round(outstar[[2]], 5)
    if(EUr_try %in% EUr_vec){print("already have"); next()}
    #----
    t <- t + 1
    #----
    wstar <- exp(instar[1:n_proj])
    l_V <- instar[n_proj + 1]
    l_C <- instar[n_proj + 2]  
    slackvec_list[[t]] <- outstar$fvec
    wstar_list[[t]] <- wstar
    Vend_vec[t] <- Vend_targ
    EUr_vec[t] <- EUr_try
    lV_vec[t] <- l_V
    lC_vec[t] <- l_C
    SOC_vec[t] <- outstar[[3]]
    MD_vec[t] <- outstar[[4]]
    Uc_vec[t] <- wstar %*% log(wstar)
    #---
    if(sum(wstar < 0) > 0){negpos[t] <- "negative"}else{negpos[t] <- "positive"}
  }
  
}

risk_vec <- sqrt(Vend_vec)
EUrtoRisk_vec = EUr_vec / risk_vec
sqtMD_vec  <- sqrt(MD_vec)
wstars <- wstar_list
df <- data.frame(EUr = EUr_vec, Risk = risk_vec, EUrtoRisk = EUrtoRisk_vec, lV = lV_vec, lC = lC_vec, SOC = SOC_vec, sqtMD = sqtMD_vec, MD = MD_vec, Uc = Uc_vec, negpos, Vend = Vend_vec)
# ind_negw <- which(df$negpos == "negative")
# n_neg <- length(ind_negw)
# n_tot <- nrow(df)
# frac_neg <- n_neg / n_tot
# print(frac_neg)
# df <- df[-ind_negw, ]
# wstars <- wstars[-ind_negw]
# ind_rm <- which(df$lEUr > 0)
# length(ind_rm)
# df <- df[-ind_rm, ]
# wstars <- wstars[-ind_rm]
#--------------------------------------------
df$SOCcat <- NA
df$SOCcat[which(df$SOC >= 0)] <- "Min"
df$SOCcat[which(df$SOC < 0)] <- "Max"
df$SOCcat <- as.factor(df$SOCcat)
#--------------------------------------------
ind_EUrOpt <- which(df$EUr == max(df$EUr))
ind_EUrtoRiskOpt <- which(df$EUrtoRisk == max(df$EUrtoRisk))
df_EUrOpt <- data.frame(opt_EUr = df$EUr[ind_EUrOpt],
                        opt_Risk_EUr = df$Risk[ind_EUrOpt],
                        opt_sqtMD_EUr = df$sqtMD[ind_EUrOpt])
df_EUrtoRiskOpt <- data.frame(opt_EUrtoRisk = df$EUrtoRisk[ind_EUrtoRiskOpt], 
                              opt_Risk_EUrtoRisk = df$Risk[ind_EUrtoRiskOpt],
                              opt_sqtMD_EUrtoRisk = df$sqtMD[ind_EUrtoRiskOpt])
gg <- ggplot(df, aes(x = Risk, y = EUr, color = SOCcat)) + geom_point()
gg <- gg + labs(title = "Portfolio Risk-Reward frontier",
                x = "Portfolio Risk", y = "Portfolio Expected Utility",
                color = "S.O.C.")
gg

gg <- ggplot(df, aes(x = Risk, y = EUrtoRisk, color = SOCcat)) + geom_point()
gg <- gg + labs(title = "Another Take on the Portfolio Risk-Reward frontier",
                x = "Portfolio Risk", y = "Portfolio Expected Utility to Risk Ratio",
                color = "S.O.C.")
gg






df$x <- df$lC * df$Uc
df$x2 <- df$Risk * df$sqtMD
df$EUr_equal_lClV <- df$sqtMD * (df$Risk + df$Uc / (2 * df$Risk))
df$lequal <- -df$EUr / (2 * df$Vend + df$Uc)
df$x3 <- df$lC / df$lV
ggplot(df, aes(x = x2, y = lC, color = SOCcat)) + geom_point()
#ggplot(df, aes(x = x2, y = lC, color = SOCcat)) + geom_point() + coord_cartesian(xlim=c(0, 1), ylim = c(-6, -4))
ggplot(df, aes(x = Risk, y = x2, color = EUr)) + geom_point() #+ coord_cartesian(xlim=c(0, 5), ylim = c(0, 2))
ggplot(df, aes(x = Risk, y = EUr_equal_lClV, color = EUr)) + geom_point()
ggplot(df, aes(x = Risk, y = x3, color = SOCcat)) + geom_point()
#--------------------------------------------
ind_rm <- which(df$SOCcat == "Min")
df <- df[-ind_rm, ]
wstars <- wstars[-ind_rm]
#--------------------------------------------
gg <- ggplot(df, aes(x = Risk, y = EUr, color = SOCcat)) + geom_point()
gg <- gg + geom_point(data = df_EUrOpt,
                      aes(x = opt_Risk_EUr, y = opt_EUr),
                      fill = "green", pch = 24, color = "black", size = 5, stroke = 2)
gg <- gg + labs(title = "Portfolio Risk-Reward frontier",
                x = "Portfolio Risk", y = "Portfolio Expected Utility",
                color = "S.O.C.")
gg


gg <- ggplot(df, aes(x = Risk, y = EUrtoRisk, color = SOCcat)) + geom_point()
# gg <- gg + geom_point(data = df_EUrtoRiskOpt,
#                       aes(x = opt_Risk_EUrtoRisk, y = opt_EUrtoRisk),
#                       fill = "green", pch = 24, color = "black", size = 5, stroke = 2)
gg <- gg + labs(title = "Portfolio Risk-Reward frontier (Another Take)",
                x = "Portfolio Risk", y = "Portfolio Expected Utility to Risk Ratio",
                color = "S.O.C.")
gg



gg <- ggplot(df, aes(x = Uc, y = sqtMD, color = Risk)) + geom_point()
gg



ggplot(df, aes(x = sqtMD, y = lC, color = SOCcat)) + geom_point()
ggplot(df, aes(x = Vend, y = EUrtoRisk, color = Uc)) + geom_point()
#--------------------------------------------

df_wStack <- data.frame(Risk = NA, EUr = NA, Project = NA, w = NA)
for(i in 1:nrow(df)){df_wStack <- rbind(df_wStack, data.frame(Risk = df$Risk[i], EUr = df$EUr[i], Project = c(1:n_proj), w = c(wstars[[i]])))}
#for(i in 1:nrow(df)){df_wStack <- rbind(df_wStack, data.frame(Risk = df$Risk[i], NEUb = df$NEU[i], project = c(1:n_proj), w = c(wstars[[i]][1:n_proj] / df$C[i])))}
df_wStack <- df_wStack[-1, ]

df_wStack$project <- as.character(df_wStack$project)
#df_wStack$w <- df_wStack$w / df$C[ind]
ind_opt <- which(df$EUr == max(df$EUr))
gg <- ggplot(df_wStack, aes(x = Risk, y = w)) + geom_area(aes(fill = project))
gg <- gg + geom_vline(xintercept = df$Risk[ind_opt], color = "green", lwd = 2)
gg <- gg + labs(title = "Budget weights over a range of risk",
                x = "Potfolio Risk", y = "Project Budget Weights")
gg

# max(subset(df_wStack, project == 3)$w)
# quantile(subset(df_wStack, project == 3)$w)
ind_rm <- which(df_wStack$w > 0.6 & df_wStack$project == 3)
df_wStack <- df_wStack[-ind_rm,]

#--------------------------------------------




df_wStack <- data.frame(Risk = NA, NEUb= NA, project = NA, w = NA)
#for(i in 1:nrow(df)){df_wStack <- rbind(df_wStack, data.frame(Risk = df$Risk[i], NEUb = df$NEUb[i], project = c(1:n_proj), w = c(wstars[[i]][1:n_proj])))}
for(i in 1:nrow(df)){df_wStack <- rbind(df_wStack, data.frame(Risk = df$Risk[i], NEUb = df$NEUb[i], project = c(1:n_proj), w = c(wstars[[i]][1:n_proj] / df$C[i])))}
df_wStack <- df_wStack[-1, ]
df_wStack$project <- as.character(df_wStack$project)
gg <- ggplot(df_wStack, aes(x = Risk, y = w)) + geom_area(aes(fill = project))
gg <- gg + geom_vline(xintercept = df$Risk[ind])
gg

#============================================
#Eigen portfolios
#wstar_opt <- wstars[[ind]]
#sum(wstar_opt / w_e)
Y <- -diag(1 / s_b) %*% eigen(Corr)$vectors
#W_e <- apply(Y, 2, function(x) x / sum(x))
#colSums(W_e)
#Y <- -eigen(Corr)$vectors
W_e <- Y
#W_e <- -eigen(Corr)$vectors
t(W_e) %*% wstar_opt
t(Y) %*% Y
EUbe <- c()
NEUbe <- c()
Risk_e <- c()
Ce <- c()
for(i in 1:ncol(W_e)){
  w_e <- W_e[, i]
  EU_b <- as.numeric(t(1 / w_e) %*% m_b)
  EUbe[i] <- EU_b
  Ce[i] <- sum(w_e)
  NEUbe[i] <- EU_b - log(Ce[i])
  Risk_e[i] <- sqrt(as.numeric(t(1 / w_e) %*% S_b %*% (1 / w_e)))
}
df_e <- data.frame(Risk_e, NEUb_e = NEUbe, C_e = Ce)
df_e <- df_e[1, ]
gg <- ggplot() + geom_point(data = df, aes(x = Risk, y = NEUb, color = MD))
gg <- gg + geom_point(data = df_e, aes(x = Risk_e, y = NEUb_e))
gg <- gg + geom_vline(xintercept = df$Risk[ind])
gg


w_e <- W_e[, 1]
EUb_e <- EUbe[1]
Vb_e <- as.numeric(t(1 / w_e) %*% S_b %*% (1 / w_e))
q <- EU_b + 1
l_endog <- -2 * Vb_e / q
invec_e <- c(w_e, l_endog)
Vb_targ <- V_b
rootfn <- F
quietly <- F
out_e <- minV_EnetUconstr(invec_e, Vb_targ, m_b, S_b, rootfn, quietly)

































































#============================================
#============================================
#============================================
#N risky assets with return and budget constraint
#============================================
m_u <- c(0.43, 0.25, 0.38)
m_lA <- c(-.65, -0.75, -0.53)
#m_lA <- c(.02, 0.03, 0.05)
cv_u <- c(0.15, 0.46, 0.29)
cv_lA <- c(0.23, 0.81, 0.51) * sign(m_lA)
s_u <- cv_u * m_u
#s2_u <- s_u^2
s_lA <- cv_lA * m_lA
#s2_lA <- s_lA^2
#E_A <- exp(m_lA + 1 / 2 * s2_lA)
n_proj <- length(m_u)
onevec <- rep(1, n_proj)
#-----------------
noisevec <- coloredNoise(n_proj^2, a = -2, normalize = T, graph = T)
Q <- matrix(exp(noisevec), n_proj, n_proj)
Corr <- Q %*% t(Q)
Corr <- Corr / max(Corr) * .98
diag(Corr) <- rep(1, n_proj)
#print(Corr)
S_u <- diag(s_u) %*% Corr %*% diag(s_u)
Su_inv <- round(solve(S_u), 5)
#-----------------
noisevec <- coloredNoise(n^2, a = -2, normalize = T, graph = T)
Q <- matrix(exp(noisevec), n, n)
Corr <- Q %*% t(Q)
Corr <- Corr / max(Corr) * .98
diag(Corr) <- rep(1, n)
S_lA <- diag(s_lA) %*% Corr %*% diag(s_lA)
V_lA <- t(onevec) %*% S_lA %*% onevec
#-----------------


# l <- eigen(Corr)$value
# e <- eigen(Corr)$vector
# print(l)
# print(e)
# #colMeans(e)
# Y <- diag(1 / s) %*% e
# W <- apply(Y, 2, function(x) x / sum(x))
# colSums(W)
# w_mkt <- W[, 1]
# round(t(w_mkt) %*% S %*% w_mkt, 4)
# round(t(W[, 2]) %*% S %*% w_mkt, 4)
# W_inv <- solve(W)
# m_effective <- W_inv %*% c(1, rep(0, (n - 1)))
# m_effective
# V_vec <- diag(t(W) %*% S %*% W)
# ER_vec <- W %*% m_effective
# V_mkt <- V_vec[1]
# ER_mkt <- ER_vec[1]
#-----
