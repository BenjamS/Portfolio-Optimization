#23/05/18
library(ggplot2)
library(gridExtra)
library(stats)
library(pracma)
library(nleqslv)
#source('D:/OneDrive - CGIAR/Documents/coloredNoise.R')
# source('~/coloredNoise.R')
#============================================
#N risky assets
#============================================
m_h <- c(0.85, .95, 1, 1.05, 1.15)
cv_h <- c(0.15, 0.35, 0.5, 0.75, 1)
s_h <- cv_h * m_h
m_lk <- log(c(1.3, 1.5, 1.8, 1.2, 1.3))
cv_lk <- c(0.1, 0.12, 0.07, 0.2, 0.3) * sign(m_lk)
s_lk <- cv_lk * m_lk
#--------------------------------------------
n_proj <- length(m_h)
onevec <- rep(1, n_proj)
#--------------------------------------------
# s2_lA <- s_lA^2
# E_lA <- sum(m_lA)
#--------------------------------------------
#Covariance matrices
#--------------------------------------------
#Endogenous params
#noisevec <- coloredNoise(n_proj^2, a = -2, normalize = T, graph = T)
#Q <- matrix(exp(noisevec), n_proj, n_proj)
Q <- exp(randn(n_proj, n_proj))
Corr <- Q %*% t(Q)
Corr <- Corr / max(Corr) * 0.5
diag(Corr) <- onevec
#print(Corr)
S_h <- diag(s_h) %*% Corr %*% diag(s_h)
write.table(round(S_h, 4), file = "D:/OneDrive - CGIAR/Documents/S_h.csv", row.names=FALSE, col.names=FALSE, sep=",")
Sh_inv <- round(solve(S_h), 6)
nab <- cbind(m_h, onevec)
Mert <- t(nab) %*% Sh_inv %*% nab
Mert_inv <- round(solve(Mert), 5)
#--------------------------------------------
#Exogenous params
noisevec <- coloredNoise(n_proj^2, a = -2, normalize = T, graph = T)
Q <- matrix(exp(noisevec), n_proj, n_proj)
Corr <- Q %*% t(Q)
Corr <- Corr / max(Corr) * 0.5
diag(Corr) <- onevec
#print(Corr)
S_lk <- diag(s_lk) %*% Corr %*% diag(s_lk)
Vexo <- t(onevec) %*% S_lk %*% onevec
#============================================

i_end <- 200
Uc <- 1
EUr <- c()
l_V <- c()
l_C <- c()
w <- list()
w_norm <- list()
V <- c()
MD <- c()
SOC <- c()
for(i in 1:i_end){
  EUrxx <- Uc - .5 + i / i_end
  EUr[i] <- EUrxx
  lxx <- -2 * Mert_inv %*% c(EUrxx, Uc)
  l_Vxx <- 1 / as.numeric(lxx[1])
  l_Cxx <- as.numeric(lxx[2]) * l_Vxx
  l_C[i] <- l_Cxx
  l_V[i] <- l_Vxx
  lwxx <- -1 / 2 * Sh_inv %*% nab %*% lxx
  wxx <- exp(lwxx)
  w_norm[[i]] <- wxx / sum(wxx)
  w[[i]] <- wxx
  Vxx <- t(lwxx) %*% S_h %*% lwxx
  V[i] <- Vxx
  SOC[i] <- ifelse((Vxx * l_Vxx < 0), "Is a Max.", "Is a Min.")
  #--check--
  MDxx <- as.numeric(t(c(1, l_Cxx)) %*% Mert %*% c(1, l_Cxx))
  MD[i] <- MDxx
  froot <- MDxx + 2 * l_Vxx * t(c(1, l_Cxx)) %*% c(EUrxx, Uc)
  lC_eff <- (sqrt(Vxx * MDxx) - EUrxx) / Uc
  lCtest <- l_Cxx / lC_eff
  froot2 <- (EUrxx + l_Cxx)^2 - Vxx * MDxx
  froot3 <- EUrxx + 2 * l_Vxx * Vxx + l_Cxx * Uc
  lwtest <- sum(lwxx) - Uc
  lV_eff <- -1 / 2 * sqrt(MDxx / Vxx)
  lVtest <- l_Vxx / lV_eff
}

Risk <- sqrt(V)
df <- data.frame(EUr, Risk, V, MD, l_V, l_C, SOC)

gg <- ggplot(df, aes(x = Risk, y = EUr, color = SOC)) + geom_point()
gg <- gg + labs(x = "Portfolio Risk", y = "Portfolio Expected Utility",
                color = "S.O.C.")
gg


ind_rm <- which(df$SOC == "Is a Min.")
df <- df[-ind_rm, ]
w <- w[-ind_rm]
w_norm <- w_norm[-ind_rm]


df_wStack <- data.frame(Risk = NA, EUr = NA, Project = NA, w = NA)
for(i in 1:nrow(df)){df_wStack <- rbind(df_wStack, data.frame(Risk = df$Risk[i], EUr = df$EUr[i], Project = c(1:n_proj), w = c(w[[i]])))}
#for(i in 1:nrow(df)){df_wStack <- rbind(df_wStack, data.frame(Risk = df$Risk[i], EUr = df$EUr[i], Project = c(1:n_proj), w = c(w_norm[[i]])))}
df_wStack <- df_wStack[-1, ]

df_wStack$Project <- as.character(df_wStack$Project)
#df_wStack$w <- df_wStack$w / df$C[ind]
#ind_opt <- which(df$EUr == max(df$EUr))
gg <- ggplot(df_wStack, aes(x = Risk, y = w)) + geom_area(aes(fill = Project))
#gg <- gg + geom_vline(xintercept = df$Risk[ind_opt], color = "green", lwd = 2)
gg <- gg + labs(x = "Potfolio Risk", y = "Project Budget Weights")
gg
































Vend_targ <- 1.9
#C_targ <- 1
#--------------------------------------------
rootfn <- T
quietly <- F
in_vec <- rnorm(n_proj + 1)
out <- nleqslv(in_vec, maxNEU_constrV_wi, jac = NULL, Vend_targ, m_h, S_h, rootfn, quietly)
rootfn <- F
in_star <- out$x
outstar <- maxNEU_constrV_wi(in_star, Vend_targ, m_h, S_h, rootfn, quietly)
wstar <- in_star[1:n_proj]
Cost <- sum(wstar)
Cost
#============================================
pwr10 <- 2
range_V <- c(0, 10)
first_i <- range_V[1] * 10^pwr10
last_i <- range_V[2] * 10^pwr10
#---------------
NEUr_vec <- c()
Vend_vec <- c()
MD_vec <- c()
SOC_vec <- c()
lV_vec <- c()
C_vec <- c()
wstar_list <- list()
slackvec_list <- list()
negpos <- c()
t <- 0
for(i in first_i:last_i){
  #----
  Vend_targ <- i / 10^pwr10
  #----
  for(j in 1:20){
    rootfn <- T
    quietly <- T
    in_vec <- runif(n_proj + 1)
    out <- try(nleqslv(in_vec, maxNEU_constrV_wi, jac = NULL, Vend_targ, m_h, S_h, rootfn, quietly))
    if(inherits(out, "try-error")){print("gotta skip"); next()}
    if(max(abs(out$fvec)) > 10^-5){print("max iter with no convergence");next()}
    #----
    instar <- out$x
    #----
    rootfn <- F
    quietly <- T
    outstar <- maxNEU_constrV_wi(instar, Vend_targ, m_h, S_h, rootfn, quietly)
    #----
    NEUr_try <- round(outstar[[2]], 5)
    if(NEUr_try %in% NEUr_vec){print("already have"); next()}
    #----
    t <- t + 1
    #----
    wstar <- instar[1:n_proj]
    l_V <- instar[n_proj + 1]
    slackvec_list[[t]] <- outstar$fvec
    wstar_list[[t]] <- wstar
    Vend_vec[t] <- Vend_targ
    NEUr_vec[t] <- NEUr_try
    lV_vec[t] <- l_V
    SOC_vec[t] <- outstar[[3]]
    MD_vec[t] <- outstar[[4]]
    C_vec[t] <- sum(wstar)
    #---
    if(sum(wstar < 0) > 0){negpos[t] <- "negative"}else{negpos[t] <- "positive"}
  }
  
}

risk_vec <- sqrt(Vend_vec)
NEUrtoRisk_vec = NEUr_vec / risk_vec
sqtMD_vec  <- sqrt(MD_vec)
wstars <- wstar_list
df <- data.frame(NEUr = NEUr_vec, Risk = risk_vec, NEUrtoRisk = NEUrtoRisk_vec, lV = lV_vec, SOC = SOC_vec, sqtMD = sqtMD_vec, MD = MD_vec, C = C_vec, negpos, Vend = Vend_vec)
ind_negw <- which(df$negpos == "negative")
n_neg <- length(ind_negw)
n_tot <- nrow(df)
frac_neg <- n_neg / n_tot
print(frac_neg)
df <- df[-ind_negw, ]
wstars <- wstars[-ind_negw]
#--------------------------------------------
df$SOCcat <- NA
df$SOCcat[which(df$SOC >= 0)] <- "Min"
df$SOCcat[which(df$SOC < 0)] <- "Max"
df$SOCcat <- as.factor(df$SOCcat)
ind_rm <- which(df$SOCcat == "Min")
df <- df[-ind_rm, ]
wstars <- wstars[-ind_rm]
#--------------------------------------------
ind_NEUrOpt <- which(df$NEUr == max(df$NEUr))
ind_NEUrtoRiskOpt <- which(df$NEUrtoRisk == max(df$NEUrtoRisk))
df_NEUrOpt <- data.frame(opt_NEUr = df$NEUr[ind_NEUrOpt],
                        opt_Risk_NEUr = df$Risk[ind_NEUrOpt],
                        opt_sqtMD_NEUr = df$sqtMD[ind_NEUrOpt])
df_NEUrtoRiskOpt <- data.frame(opt_NEUrtoRisk = df$NEUrtoRisk[ind_NEUrtoRiskOpt], 
                              opt_Risk_NEUrtoRisk = df$Risk[ind_NEUrtoRiskOpt],
                              opt_sqtMD_NEUrtoRisk = df$sqtMD[ind_NEUrtoRiskOpt])
gg <- ggplot(df, aes(x = Risk, y = NEUr, color = SOCcat)) + geom_point()
gg <- gg + labs(title = "Portfolio Risk-Reward frontier",
                x = "Portfolio Risk", y = "Portfolio Expected Utility",
                color = "S.O.C.")
gg

gg <- ggplot(df, aes(x = Risk, y = NEUrtoRisk, color = SOCcat)) + geom_point()
gg <- gg + labs(title = "Another Take on the Portfolio Risk-Reward frontier",
                x = "Portfolio Risk", y = "Portfolio Expected Utility to Risk Ratio",
                color = "S.O.C.")
gg


  




df$x <- df$lC * df$Uc
df$x2 <- df$Risk * df$sqtMD
df$EUr_equal_lClV <- df$sqtMD * (df$Risk + df$Uc / (2 * df$Risk))
df$lequal <- -df$EUr / (2 * df$Vend + df$Uc)
df$x3 <- df$lC / df$lV
ggplot(df, aes(x = x2, y = lC, color = SOCcat)) + geom_point()
#ggplot(df, aes(x = x2, y = lC, color = SOCcat)) + geom_point() + coord_cartesian(xlim=c(0, 1), ylim = c(-6, -4))
ggplot(df, aes(x = Risk, y = x2, color = EUr)) + geom_point() #+ coord_cartesian(xlim=c(0, 5), ylim = c(0, 2))
ggplot(df, aes(x = Risk, y = EUr_equal_lClV, color = EUr)) + geom_point()
ggplot(df, aes(x = Risk, y = x3, color = SOCcat)) + geom_point()
#--------------------------------------------
ind_rm <- which(df$SOCcat == "Min")
df <- df[-ind_rm, ]
wstars <- wstars[-ind_rm]
#--------------------------------------------
gg <- ggplot(df, aes(x = Risk, y = EUr, color = SOCcat)) + geom_point()
gg <- gg + geom_point(data = df_EUrOpt,
                      aes(x = opt_Risk_EUr, y = opt_EUr),
                      fill = "green", pch = 24, color = "black", size = 5, stroke = 2)
gg <- gg + labs(title = "Portfolio Risk-Reward frontier",
                x = "Portfolio Risk", y = "Portfolio Expected Utility",
                color = "S.O.C.")
gg


gg <- ggplot(df, aes(x = Risk, y = EUrtoRisk, color = SOCcat)) + geom_point()
# gg <- gg + geom_point(data = df_EUrtoRiskOpt,
#                       aes(x = opt_Risk_EUrtoRisk, y = opt_EUrtoRisk),
#                       fill = "green", pch = 24, color = "black", size = 5, stroke = 2)
gg <- gg + labs(title = "Portfolio Risk-Reward frontier (Another Take)",
                x = "Portfolio Risk", y = "Portfolio Expected Utility to Risk Ratio",
                color = "S.O.C.")
gg



gg <- ggplot(df, aes(x = Uc, y = sqtMD, color = Risk)) + geom_point()
gg



ggplot(df, aes(x = sqtMD, y = lC, color = SOCcat)) + geom_point()
ggplot(df, aes(x = Vend, y = EUrtoRisk, color = Uc)) + geom_point()
#--------------------------------------------

df_wStack <- data.frame(Risk = NA, EUr = NA, Project = NA, w = NA)
for(i in 1:nrow(df)){df_wStack <- rbind(df_wStack, data.frame(Risk = df$Risk[i], EUr = df$EUr[i], Project = c(1:n_proj), w = c(wstars[[i]])))}
#for(i in 1:nrow(df)){df_wStack <- rbind(df_wStack, data.frame(Risk = df$Risk[i], NEUb = df$NEU[i], project = c(1:n_proj), w = c(wstars[[i]][1:n_proj] / df$C[i])))}
df_wStack <- df_wStack[-1, ]

df_wStack$project <- as.character(df_wStack$project)
#df_wStack$w <- df_wStack$w / df$C[ind]
ind_opt <- which(df$EUr == max(df$EUr))
gg <- ggplot(df_wStack, aes(x = Risk, y = w)) + geom_area(aes(fill = project))
gg <- gg + geom_vline(xintercept = df$Risk[ind_opt], color = "green", lwd = 2)
gg <- gg + labs(title = "Budget weights over a range of risk",
                x = "Potfolio Risk", y = "Project Budget Weights")
gg

# max(subset(df_wStack, project == 3)$w)
# quantile(subset(df_wStack, project == 3)$w)
ind_rm <- which(df_wStack$w > 0.6 & df_wStack$project == 3)
df_wStack <- df_wStack[-ind_rm,]

#--------------------------------------------




df_wStack <- data.frame(Risk = NA, NEUb= NA, project = NA, w = NA)
#for(i in 1:nrow(df)){df_wStack <- rbind(df_wStack, data.frame(Risk = df$Risk[i], NEUb = df$NEUb[i], project = c(1:n_proj), w = c(wstars[[i]][1:n_proj])))}
for(i in 1:nrow(df)){df_wStack <- rbind(df_wStack, data.frame(Risk = df$Risk[i], NEUb = df$NEUb[i], project = c(1:n_proj), w = c(wstars[[i]][1:n_proj] / df$C[i])))}
df_wStack <- df_wStack[-1, ]
df_wStack$project <- as.character(df_wStack$project)
gg <- ggplot(df_wStack, aes(x = Risk, y = w)) + geom_area(aes(fill = project))
gg <- gg + geom_vline(xintercept = df$Risk[ind])
gg

#============================================
#Eigen portfolios
#wstar_opt <- wstars[[ind]]
#sum(wstar_opt / w_e)
Y <- -diag(1 / s_b) %*% eigen(Corr)$vectors
#W_e <- apply(Y, 2, function(x) x / sum(x))
#colSums(W_e)
#Y <- -eigen(Corr)$vectors
W_e <- Y
#W_e <- -eigen(Corr)$vectors
t(W_e) %*% wstar_opt
t(Y) %*% Y
EUbe <- c()
NEUbe <- c()
Risk_e <- c()
Ce <- c()
for(i in 1:ncol(W_e)){
  w_e <- W_e[, i]
  EU_b <- as.numeric(t(1 / w_e) %*% m_b)
  EUbe[i] <- EU_b
  Ce[i] <- sum(w_e)
  NEUbe[i] <- EU_b - log(Ce[i])
  Risk_e[i] <- sqrt(as.numeric(t(1 / w_e) %*% S_b %*% (1 / w_e)))
}
df_e <- data.frame(Risk_e, NEUb_e = NEUbe, C_e = Ce)
df_e <- df_e[1, ]
gg <- ggplot() + geom_point(data = df, aes(x = Risk, y = NEUb, color = MD))
gg <- gg + geom_point(data = df_e, aes(x = Risk_e, y = NEUb_e))
gg <- gg + geom_vline(xintercept = df$Risk[ind])
gg


w_e <- W_e[, 1]
EUb_e <- EUbe[1]
Vb_e <- as.numeric(t(1 / w_e) %*% S_b %*% (1 / w_e))
q <- EU_b + 1
l_endog <- -2 * Vb_e / q
invec_e <- c(w_e, l_endog)
Vb_targ <- V_b
rootfn <- F
quietly <- F
out_e <- minV_EnetUconstr(invec_e, Vb_targ, m_b, S_b, rootfn, quietly)

































































#============================================
#============================================
#============================================
#N risky assets with return and budget constraint
#============================================
m_u <- c(0.43, 0.25, 0.38)
m_lA <- c(-.65, -0.75, -0.53)
#m_lA <- c(.02, 0.03, 0.05)
cv_u <- c(0.15, 0.46, 0.29)
cv_lA <- c(0.23, 0.81, 0.51) * sign(m_lA)
s_u <- cv_u * m_u
#s2_u <- s_u^2
s_lA <- cv_lA * m_lA
#s2_lA <- s_lA^2
#E_A <- exp(m_lA + 1 / 2 * s2_lA)
n_proj <- length(m_u)
onevec <- rep(1, n_proj)
#-----------------
noisevec <- coloredNoise(n_proj^2, a = -2, normalize = T, graph = T)
Q <- matrix(exp(noisevec), n_proj, n_proj)
Corr <- Q %*% t(Q)
Corr <- Corr / max(Corr) * .98
diag(Corr) <- rep(1, n_proj)
#print(Corr)
S_u <- diag(s_u) %*% Corr %*% diag(s_u)
Su_inv <- round(solve(S_u), 5)
#-----------------
noisevec <- coloredNoise(n^2, a = -2, normalize = T, graph = T)
Q <- matrix(exp(noisevec), n, n)
Corr <- Q %*% t(Q)
Corr <- Corr / max(Corr) * .98
diag(Corr) <- rep(1, n)
S_lA <- diag(s_lA) %*% Corr %*% diag(s_lA)
V_lA <- t(onevec) %*% S_lA %*% onevec
#-----------------


# l <- eigen(Corr)$value
# e <- eigen(Corr)$vector
# print(l)
# print(e)
# #colMeans(e)
# Y <- diag(1 / s) %*% e
# W <- apply(Y, 2, function(x) x / sum(x))
# colSums(W)
# w_mkt <- W[, 1]
# round(t(w_mkt) %*% S %*% w_mkt, 4)
# round(t(W[, 2]) %*% S %*% w_mkt, 4)
# W_inv <- solve(W)
# m_effective <- W_inv %*% c(1, rep(0, (n - 1)))
# m_effective
# V_vec <- diag(t(W) %*% S %*% W)
# ER_vec <- W %*% m_effective
# V_mkt <- V_vec[1]
# ER_mkt <- ER_vec[1]
#-----
